using Antlr4.Runtime;
using SSLang.Generated;
using System;
using System.IO;
using System.Reflection;

namespace SSLang
{
	/// <summary>
	/// Core type for managing the compilation of an SSL source file.
	/// </summary>
	public sealed class Compiler : IDisposable
	{
		#region Fields
		/// <summary>
		/// The version of the current compiler library.
		/// </summary>
		public static readonly Version LIBRARY_VERSION;
		/// <summary>
		/// The path to the source file for this compiler instance.
		/// </summary>
		public readonly string SourcePath;
		/// <summary>
		/// The filename of the source file, by iteself without the directory structure.
		/// </summary>
		public readonly string SourceFile;

		private bool _isDisposed = false;
		#endregion // Fields

		/// <summary>
		/// Create a new compiler engine to compile the source file.
		/// </summary>
		/// <param name="path">The path to the source file to load and compile.</param>
		public Compiler(string path)
		{
			if (String.IsNullOrWhiteSpace(path))
				throw new ArgumentException("The passed path cannot be null or empty.", nameof(path));
			try
			{
				SourcePath = Path.GetFullPath(path);
				SourceFile = Path.GetFileName(SourcePath);
			}
			catch
			{
				throw new ArgumentException($"The input path '{path}' is not a valid filesystem path.", nameof(path));
			}
		}
		~Compiler()
		{
			dispose(false);
		}

		/// <summary>
		/// Performs the compilation process on the passed file.
		/// </summary>
		/// <param name="options">The options to compile with.</param>
		/// <param name="error">The error generated by the compilation process.</param>
		/// <returns>If the compilation process was successful. If <c>false</c>, the error will be set.</returns>
		public bool Compile(CompilerOptions options, out CompilerError error)
		{
			if (options == null)
				throw new ArgumentNullException(nameof(options));
			if (!File.Exists(SourcePath))
			{
				error = new CompilerError(CompilerStage.Parser, 0, 0, $"The input file '{SourcePath}' does not exist.");
				return false;
			}

			// Load the source
			string source = "";
			try
			{
				source = File.ReadAllText(SourcePath);
			}
			catch (Exception e)
			{
				error = new CompilerError(CompilerStage.Parser, 0, 0, $"Unable to read source file - {e.Message}");
				return false;
			}

			// Create the lexer and parser
			AntlrInputStream inStream = new AntlrInputStream(source);
			SSLLexer lexer = new SSLLexer(inStream);
			CommonTokenStream tokenStream = new CommonTokenStream(lexer);
			SSL parser = new SSL(tokenStream);

			// Register our custom error listener
			lexer.RemoveErrorListeners();
			parser.RemoveErrorListeners();
			var errl = new ErrorListener();
			lexer.AddErrorListener(errl);
			parser.AddErrorListener(errl);

			// Check the version statement first
			var verCtx = parser.versionMetaStatement();
			if (errl.Error != null)
			{
				error = errl.Error;
				return false;
			}
			if (verCtx != null && !checkVersion(verCtx, out error))
				return false;

			error = null;
			return true;
		}

		private bool checkVersion(SSL.VersionMetaStatementContext ctx, out CompilerError error)
		{
			if (!Version.TryParse(ctx.Version.Text, out var version))
			{
				error = new CompilerError(CompilerStage.Parser, (uint)ctx.Start.Line, (uint)ctx.Start.StartIndex, $"Unable to parse version statement '{ctx.Version.Text}'.");
				return false;
			}
			if (version > LIBRARY_VERSION)
			{
				error = new CompilerError(CompilerStage.Parser, (uint)ctx.Start.Line, 0,
					$"Version mismatch - requires version '{version}', but highest available is version '{LIBRARY_VERSION.Major}.{LIBRARY_VERSION.Minor}.{LIBRARY_VERSION.Build}'.");
				return false;
			}
			error = null;
			return true;
		}

		#region IDisposable
		public void Dispose()
		{
			dispose(true);
			GC.SuppressFinalize(this);
		}

		private void dispose(bool disposing)
		{
			if (!_isDisposed)
			{

			}
			_isDisposed = true;
		}
		#endregion // IDisposable

		static Compiler()
		{
			LIBRARY_VERSION = Assembly.GetExecutingAssembly().GetName().Version;
		}
	}

	/// <summary>
	/// Represents the various stages of the compilation process.
	/// </summary>
	public enum CompilerStage
	{
		/// <summary>
		/// The initial source lexing and parsing phase.
		/// </summary>
		Parser,
		/// <summary>
		/// The translation phase from SSL to GLSL.
		/// </summary>
		Translator,
		/// <summary>
		/// The compilation stage using the Vulkan SDK.
		/// </summary>
		Compiler,
		/// <summary>
		/// Writing the output of the compilation process.
		/// </summary>
		Output
	}
}
